#include <LiquidCrystal_I2C.h>
#include <LedControl.h>
#include <ezButton.h>
#include <Wire.h>
#include "binary.h"

const int DIN_1 = 8;
const int CS_1 = 9;
const int CLK_1 = 10;
const int DIN_2 = 11;
const int CS_2 = 12;
const int CLK_2 = 13;
const int button_joystick = 2;
const int cooldown_500 = 500;
const int cooldown_250 = 250;
const int Paint_cursor_flicker_cooldown = 400;

int posX = 1;
int posY = 1;
uint8_t TTT_cursorFlickerIndex = 0;
uint8_t playerTurn = 1;   //1 is X, 2 is O
uint8_t currentTile = 1;
uint8_t winner;
uint8_t winningLayout;
uint8_t paddle_width = 5; //determines the paddle width in pong. 3, 5 or 7
uint8_t Paint_brush_size = 1;
uint8_t Paint_mode = 1;   //1 = invert, 2 = erease, 3 = draw
uint8_t Paint_title_position = 1;
uint16_t Paint_speed = 250;
uint8_t paddle_pos = 11;

bool TTT_ai;
bool TTT_ai_lock_turn;
bool alternate_TTT_cursorAnimation;
bool joystick_cooldown;
bool joystick_cooldown_2;
bool go_home;
bool in_paint_menu;
bool Paint_cursor;
bool Paint_invert_cooldown;
bool Paint_title_move_direction;
bool button_state;
bool in_program;

uint8_t animation_TTT;
uint8_t animation_paint;
uint8_t animation_settings;

unsigned long currentMillis;
unsigned long previousMillis_gameSelector = 0;
unsigned long previousMillis_cursor_animation = 0;
unsigned long previousMillis_joystick_input_X = 0;
unsigned long previousMillis_joystick_input_Y = 0;
unsigned long previousMillis_joystick_currently_pressed = 0;
unsigned long previousMillis_joystick_currently_pressed_stationary = 0;
unsigned long previousMillis_TTT_ai_move = 0;
unsigned long previousMillis_Paint_move_title = 0;
unsigned long previousMillis_joystick_move_animation = 0;
unsigned long previousMillis_Pong_paddle_cooldown = 0;
unsigned long previousMillis_Pong_ball_update = 0;
unsigned long joystick_pressed_duration_ = 0;
unsigned long joystick_pressed_duration_stationary = 0;

ezButton joystickButton(button_joystick);
LedControl lc_1 = LedControl(DIN_1, CLK_1, CS_1, 4);
LedControl lc_2 = LedControl(DIN_2, CLK_2, CS_2, 4);
LiquidCrystal_I2C lcd(0x27, 16, 2); //16 columns, 2 rows

bool matrix[16][32];
int8_t matrix_overwrite[16][32];

uint8_t TTT_grid[3][3];  //0 = empty, 1 = X, 2 = O      [y][x]

bool TTT_winLayouts[8][3][3] = { // 8 possible win layouts
  {
    {1,0,0},
    {1,0,0},
    {1,0,0}
  },{
    {0,1,0},
    {0,1,0},
    {0,1,0}
  },{
    {0,0,1},
    {0,0,1},
    {0,0,1}
  },{
    {1,1,1},
    {0,0,0},
    {0,0,0}
  },{
    {0,0,0},
    {1,1,1},
    {0,0,0}
  },{
    {0,0,0},
    {0,0,0},
    {1,1,1}
  },{
    {1,0,0},
    {0,1,0},
    {0,0,1}
  },{
    {0,0,1},
    {0,1,0},
    {1,0,0}
  }
};

const int Paint_MAX_SAVES = 5;
byte Paint_saves_byte_matrix[Paint_MAX_SAVES][16][32 / 8]; //storing 8 bools in one byte
char Paint_saves_name[Paint_MAX_SAVES][7+1] = { // +1 is for the \0 null terminator
  {"save1  "},
  {"save2  "},
  {"save3  "},
  {"save4  "},
  {"save5  "}
};

const uint8_t PROGMEM shape_X_large[] = {
  0,0,1,0,0,0,0,0,0,1,0,0,
  0,1,1,1,0,0,0,0,1,1,1,0,
  1,1,1,1,1,0,0,1,1,1,1,1,
  0,1,1,1,1,1,1,1,1,1,1,0,
  0,0,1,1,1,1,1,1,1,1,0,0,
  0,0,0,1,1,1,1,1,1,0,0,0,
  0,0,0,1,1,1,1,1,1,0,0,0,
  0,0,1,1,1,1,1,1,1,1,0,0,
  0,1,1,1,1,1,1,1,1,1,1,0,
  1,1,1,1,1,0,0,1,1,1,1,1,
  0,1,1,1,0,0,0,0,1,1,1,0,
  0,0,1,0,0,0,0,0,0,1,0,0
};
const uint8_t PROGMEM shape_O_large[] = {
  0,0,0,0,1,1,1,1,0,0,0,0,
  0,0,1,1,1,1,1,1,1,1,0,0,
  0,1,1,1,1,1,1,1,1,1,1,0,
  0,1,1,1,0,0,0,0,1,1,1,0,
  1,1,1,0,0,0,0,0,0,1,1,1,
  1,1,1,0,0,0,0,0,0,1,1,1,
  1,1,1,0,0,0,0,0,0,1,1,1,
  1,1,1,0,0,0,0,0,0,1,1,1,
  0,1,1,1,0,0,0,0,1,1,1,0,
  0,1,1,1,1,1,1,1,1,1,1,0,
  0,0,1,1,1,1,1,1,1,1,0,0,
  0,0,0,0,1,1,1,1,0,0,0,0
};
const uint8_t PROGMEM shape_grid[] = {
  0,0,0,1,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,1,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,1,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,1,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,1,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,1,0,0,0
};
const uint8_t PROGMEM shape_pong[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
const uint8_t PROGMEM shape_smiley[] = {
  0,0,0,0,0,0,0,0,
  0,0,1,0,0,1,0,0,
  0,0,1,0,0,1,0,0,
  0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,
  0,1,0,0,0,0,1,0,
  0,0,1,1,1,1,0,0,
  0,0,0,0,0,0,0,0
};
const uint8_t PROGMEM shape_settings_1[] = {
  0,0,0,1,0,0,0,0,0,0,1,0,0,0,
  0,0,0,1,1,0,1,1,0,1,1,0,0,0,
  0,0,0,0,1,0,1,1,0,1,0,0,0,0,
  1,1,0,0,1,1,1,1,1,1,0,0,1,1,
  0,1,1,1,1,1,1,1,1,1,1,1,1,0,
  0,0,0,1,1,1,0,0,1,1,1,0,0,0,
  0,1,1,1,1,0,0,0,0,1,1,1,1,0,
  0,1,1,1,1,0,0,0,0,1,1,1,1,0,
  0,0,0,1,1,1,0,0,1,1,1,0,0,0,
  0,1,1,1,1,1,1,1,1,1,1,1,1,0,
  1,1,0,0,1,1,1,1,1,1,0,0,1,1,
  0,0,0,0,1,0,1,1,0,1,0,0,0,0,
  0,0,0,1,1,0,1,1,0,1,1,0,0,0,
  0,0,0,1,0,0,0,0,0,0,1,0,0,0
};
const uint8_t PROGMEM shape_settings_2[] = {
  0,0,0,1,0,0,0,0,0,0,1,0,0,0,
  0,0,0,1,1,0,0,0,0,1,1,0,0,0,
  0,0,0,0,1,1,0,0,1,1,0,0,0,0,
  1,1,0,1,1,1,1,1,1,1,1,0,1,1,
  0,1,1,1,1,1,1,1,1,1,1,1,1,0,
  0,0,1,1,1,0,0,0,0,1,1,1,0,0,
  0,0,0,1,1,0,0,0,0,1,1,0,0,0,
  0,0,0,1,1,0,0,0,0,1,1,0,0,0,
  0,0,1,1,1,0,0,0,0,1,1,1,0,0,
  0,1,1,1,1,1,1,1,1,1,1,1,1,0,
  1,1,0,1,1,1,1,1,1,1,1,0,1,1,
  0,0,0,0,1,1,0,0,1,1,0,0,0,0,
  0,0,0,1,1,0,0,0,0,1,1,0,0,0,
  0,0,0,1,0,0,0,0,0,0,1,0,0,0
};
const uint8_t PROGMEM shape_filled[] = {
  1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1
};
const uint8_t PROGMEM shape_X[] = {
  1,0,0,1,
  0,1,1,0,
  0,1,1,0,
  1,0,0,1
};
const uint8_t PROGMEM shape_O[] = {
  0,1,1,0,
  1,0,0,1,
  1,0,0,1,
  0,1,1,0
};
const uint8_t PROGMEM shape_Empty[] = {
  0,0,0,0,
  0,0,0,0,
  0,0,0,0,
  0,0,0,0
};
const uint8_t PROGMEM shape_line_horizontal[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte ArrowUpDown[] = {
  00100,
  01010,
  10001,
  00000,
  00000,
  10001,
  01010,
  00100
};

uint8_t setting_brightness = 1;
uint8_t setting_volume = 30;

int8_t gameselector_index = 1;
int8_t settings_index = 0;
String gameSelectorList[4] = {"   TicTacToe    ","      Pong      ","     Paint      ","    Settings    "};
String settingsList[2] = {"< Brightness >","<   Volume   >"};

void setup() {
  Serial.begin(9600);
 
  pinMode(button_joystick, INPUT_PULLUP);

  lc_1.shutdown(0, false);    // turn off power saving mode
  lc_1.shutdown(1, false);
  lc_1.shutdown(2, false);
  lc_1.shutdown(3, false);
  lc_2.shutdown(0, false);
  lc_2.shutdown(1, false);
  lc_2.shutdown(2, false);
  lc_2.shutdown(3, false);
  lc_1.clearDisplay(0);
  lc_1.clearDisplay(1);
  lc_1.clearDisplay(2);
  lc_1.clearDisplay(3);
  lc_2.clearDisplay(0);
  lc_2.clearDisplay(1);
  lc_2.clearDisplay(2);
  lc_2.clearDisplay(3);
  lc_1.setIntensity(0, setting_brightness);
  lc_1.setIntensity(1, setting_brightness);
  lc_1.setIntensity(2, setting_brightness);
  lc_1.setIntensity(3, setting_brightness);
  lc_2.setIntensity(0, setting_brightness);
  lc_2.setIntensity(1, setting_brightness);
  lc_2.setIntensity(2, setting_brightness);
  lc_2.setIntensity(3, setting_brightness);

  lcd.clear();
  lcd.init();
  lcd.backlight();
  lcd.setCursor(0,0);
  lcd.noAutoscroll();
  lcd.createChar(0, ArrowUpDown);
  clearMatrixOverwrite();
}

void loop() {
  gameselector();
}

void TicTacToe() {
  if (go_home) {
    go_home = false;
    return;
  }
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(F("Game: TicTacToe"));
  while (winner == 0) {
    
    lcd.setCursor(0, 1);
    if (TTT_ai && playerTurn == 2) {
      lcd.print(F("AI turn:     "));
      TTT_aiMove();
    } else {
      lcd.print(F("Player turn: "));
    }
    if (playerTurn == 1) {
      lcd.print(F("X "));
    }
    else {
      if (TTT_ai) {
        lcd.print(F("X"));
      } else {
        lcd.print(F("O "));
      }
    }
    currentMillis = millis();
    if (!TTT_ai_lock_turn) {
      TTT_joystickInput();
    }
    
    TTT_cursorAnimation();
    
    winner = TTT_checkWinner();
    if (winner > 0) {
      if (winner != 3) {
        for (int row = 0; row < 3; row++) {
          for (int col = 0; col < 3; col++) {
            TTT_grid[row][col] = TTT_winLayouts[winningLayout][row][col] * winner;
          }
        }
      }
      TTT_winningScreen();
      return;
    }
  }
}

void TTT_joystickInput() {

  if (joystick_moveLeft() && posX > 0) {
    if (currentMillis - previousMillis_joystick_input_X > cooldown_500) {
      previousMillis_joystick_input_X = currentMillis;
      posX--;
    }
  }
  if (joystick_moveRight() && posX < 2) {
    if (currentMillis - previousMillis_joystick_input_X > cooldown_500) {
      previousMillis_joystick_input_X = currentMillis;
      posX++;
    }
  }
  if (joystick_moveUp() && posY > 0) {
    if (currentMillis - previousMillis_joystick_input_Y > cooldown_500) {
      previousMillis_joystick_input_Y = currentMillis;
      posY--;
    }
  }
  if (joystick_moveDown() && posY < 2) {
    if (currentMillis - previousMillis_joystick_input_Y > cooldown_500) {
      previousMillis_joystick_input_Y = currentMillis;
      posY++;
    }
  }
  if (joystick_isPressed() && currentTile == 0) {
    TTT_grid[posY][posX] = playerTurn;
    playerTurn = playerTurn % 2 + 1;
  }
}

void TTT_cursorAnimation() {
  currentTile = TTT_grid[posY][posX];

  if (currentMillis - previousMillis_cursor_animation > 100) {
    previousMillis_cursor_animation = currentMillis;
    alternate_TTT_cursorAnimation = !alternate_TTT_cursorAnimation;

    clearMatrix();
    TTT_setTiles();

    bool state = currentTile != 1; // if tile is 0 (none) or 2 (O) state = true, if tile is 1 (X) state = false. This creates an inverted animation on X tiles.
    
    if (TTT_cursorFlickerIndex == 0) {
      matrix[posY * 6 + 1][posX * 6 + 1] = state;
    } else if (TTT_cursorFlickerIndex == 1) {
      matrix[posY * 6 + 1][posX * 6 + 1] = state;
      matrix[posY * 6 + 1][posX * 6 + 2] = state;
    } else if (TTT_cursorFlickerIndex == 2) {
      matrix[posY * 6 + 1][posX * 6 + 2] = state;
    } else if (TTT_cursorFlickerIndex == 3) {
      matrix[posY * 6 + 1][posX * 6 + 2] = state;
      matrix[posY * 6 + 2][posX * 6 + 2] = state;
    } else if (TTT_cursorFlickerIndex == 4) {
      matrix[posY * 6 + 2][posX * 6 + 2] = state;
    } else if (TTT_cursorFlickerIndex == 5) {
      matrix[posY * 6 + 2][posX * 6 + 2] = state;
      matrix[posY * 6 + 2][posX * 6 + 1] = state;
    } else if (TTT_cursorFlickerIndex == 6) {
      matrix[posY * 6 + 2][posX * 6 + 1] = state;
    } else {
      matrix[posY * 6 + 2][posX * 6 + 1] = state;
      matrix[posY * 6 + 1][posX * 6 + 1] = state;
    }
    TTT_cursorFlickerIndex = (TTT_cursorFlickerIndex + 1) % 8;
    displayMatrix();
  }
}

void TTT_winningScreen() {
  unsigned long previousMillis = 0;
  bool alternate_animation = true;
  bool playAgain = true;
  lcd.clear();

  while (!joystick_isPressed()) {
    lcd.setCursor(0, 0);
    if (winner == 1) lcd.print(F("X won the game!"));
    if (winner == 2 && !TTT_ai) lcd.print(F("O won the game!"));
    if (winner == 2 && TTT_ai) lcd.print(F("AI won the game!"));
    if (winner == 3) lcd.print(F("Draw!"));
    lcd.setCursor(0, 1);
    lcd.print(F("again? "));
    if (playAgain) {
      lcd.print(F(">Y< N "));
    } else {
      lcd.print(F(" Y >N<"));
    }
    if (joystick_moveLeft()) playAgain = true;
    if (joystick_moveRight()) playAgain = false;
    if (joystick_isPressed()) {
      winner = 0;
      for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
          TTT_grid[row][col] = 0;
        }
      }
      clearMatrix();
      displayMatrix();
      if (playAgain) {
        TicTacToe();
      } else {
        return;
      }
    }
    unsigned long currentMillis = millis();
    if (currentMillis - previousMillis > 500) {
      previousMillis = currentMillis;
      alternate_animation = !alternate_animation;
      clearMatrix();
  	  if (alternate_animation) {
        if (winner == 1) fillMatrix(shape_X_large,12,12,2,2);
        if (winner == 2) fillMatrix(shape_O_large,12,12,2,2);
      }
      else {
        TTT_setTiles();
      }
      displayMatrix();
    }
  }
}

int TTT_checkWinner() {
  for (int i = 0; i < 8; i++) { //check if X (player 1) won
    bool win = true;
    for (int row = 0; row < 3; row++) {
      for (int col = 0; col < 3; col++) {
        if (TTT_winLayouts[i][row][col] == 1) {
          if (TTT_grid[row][col] != TTT_winLayouts[i][row][col]) {
            win = false;
          }
        }
      }
    }
    if (win) {
      winningLayout = i;
      return 1; //position i of TTT_winLayouts is winner
    }
  }
  for (int i = 0; i < 8; i++) { //check if O (player 2) won
    bool win = true;
    for (int row = 0; row < 3; row++) {
      for (int col = 0; col < 3; col++) {
        if (TTT_winLayouts[i][row][col] == 1) {
          if (TTT_grid[row][col] != TTT_winLayouts[i][row][col] + 1) {
            win = false;
          }
        }
      }
    }
    if (win) {
      winningLayout = i;
      return 2; //position i of TTT_winLayouts is winner
    }
  }

  int count = 0;
  for (int row = 0; row < 3; row++) {
    for (int col = 0; col < 3; col++) {
      if (TTT_grid[row][col] != 0) count++; //count how many tiles are occupied
    }
  }
  if (count == 9) {
    winningLayout = 3; //draw
    return 3;
  }
  return 0;
}

void TTT_aiMove() {
  if (!TTT_ai_lock_turn) {

    int grid_copy[5][5] = {
      {-1,-1,-1,-1,-1},
      {-1,-1,-1,-1,-1},
      {-1,-1,-1,-1,-1},
      {-1,-1,-1,-1,-1},
      {-1,-1,-1,-1,-1}
    };
    const int offsets[8][2] = {
      {0,1},
      {0,-1},
      {1,0},
      {-1,0},
      {1,1},
      {1,-1},
      {-1,-1},
      {-1,1},
    };
    for (int row = 0; row < 3; row++) {
      for (int col = 0; col < 3; col++) {
        grid_copy[row + 1][col + 1] = TTT_grid[row][col];
      }
    }

    do {
      posX = random(3);
      posY = random(3);
      if (TTT_grid[posY][posX] == 0) {
        TTT_ai_lock_turn = true;
      }
    } while (TTT_grid[posY][posX] != 0 && !TTT_ai_lock_turn);

    for (int i = 1; i <= 2; i++) {
      for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
          for (int j = 0; j < 8; j++) {
            int8_t offsetRow = offsets[j][0];
            int8_t offsetCol = offsets[j][1];
            int8_t current_tile = grid_copy[row + 1][col + 1];
            int8_t neighbor_tile = grid_copy[row + offsetRow + 1][col + offsetCol + 1];
            int8_t neighbor_tile2 = grid_copy[row + offsetRow * 2 + 1][col + offsetCol * 2 + 1];
            if (current_tile == i && neighbor_tile == i && neighbor_tile2 == 0) {
              posX = col + offsetCol * 2;
              posY = row + offsetRow * 2;
              TTT_ai_lock_turn = true;
            }
            if (current_tile == i && neighbor_tile == 0 && neighbor_tile2 == i) {
              posX = col + offsetCol;
              posY = row + offsetRow;
              TTT_ai_lock_turn = true;
            }
          }
        }
      }
    }
    if (TTT_ai_lock_turn) {
      previousMillis_TTT_ai_move = currentMillis;
    }
  }
  if (currentMillis - previousMillis_TTT_ai_move > 1000) {
    TTT_grid[posY][posX] = 2;
    playerTurn = 1;
    TTT_ai_lock_turn = false;
  }
}

void TTT_selectMode() {
  TTT_ai = false;
  lcd.clear();
  fillMatrix(shape_grid,12,12,2,2);
  displayMatrix();
  while (!joystick_isPressed()) {
    lcd.setCursor(0, 0);
    lcd.print(F("Play aganst AI?"));
    lcd.setCursor(0, 1);
    if (TTT_ai) {
      lcd.print(F("   >Yes<  No "));
    } else {
      lcd.print(F("    Yes  >No<"));
    }
    if (joystick_moveLeft()) TTT_ai = true;
    if (joystick_moveRight()) TTT_ai = false;
    if (joystick_isPressed()) {
      clearMatrix();
      return;
    }
    if (joystick_moveUp()) {
      go_home = true;
      return;
    }
  }
}

void TTT_setTiles() {
  for (int row = 0; row < 3; row++) {
    for (int col = 0; col < 3; col++) {
      if (TTT_grid[row][col] == 1) {
        fillMatrix(shape_X, 4, 4, row * 6, col * 6);
      } else if (TTT_grid[row][col] == 2) {
        fillMatrix(shape_O, 4, 4, row * 6, col * 6);
      } else {
        fillMatrix(shape_Empty, 4, 4, row * 6, col * 6);
      }
    }
  }
}

void Pong() {
  Pong_selectMode();
  if (go_home) {
    go_home = false;
    return;
  }
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(F("Playing Pong"));
  clearMatrix();
  fillMatrix(shape_line_horizontal, 1, 32, 0, 0);
  displayMatrix();
  double ball_x = 14;
  double ball_y = 11;
  int8_t x;
  int8_t y = 1;
  int16_t angle = 45;  // 0 is ball facing up
  double radians;

  in_program = true;
  int update_interval = 150;
  int update_count = 0;
  int score = 0;
  Pong_displayScore(score);
  Serial.println(0); // for some reason this fixes a pixel at matrix[15][26] that otherwise stays off
  while (in_program) {

    if (joystick_isPressed()) {
      update_interval -= 10;
    }

    currentMillis = millis();
    Pong_paddleControl(update_interval);

    if (currentMillis - previousMillis_Pong_ball_update > update_interval) {
      previousMillis_Pong_ball_update = currentMillis;
      matrix[y][x] = 0;
      displayPixel(y, x);
      radians = (angle - 90) * PI / 180;
      ball_x += constrain(cos(radians) * 1.5, -1, 1);
      ball_y += constrain(sin(radians) * 1.5, -1, 1);
      x = round(ball_x);
      y = round(ball_y);
      matrix[y][x] = 1;
      //Serial.println((String) "x: " + x + "  y: " + y + "         x: " + ball_x + "  y: " + ball_y);
      displayPixel(y, x);

      //             next position == not on paddle
      if (y == 14 && matrix[15][constrain(x + round(constrain(cos(radians) * 1.4, -1, 1)), 0, 31)] == 0 && matrix[15][x] == 0) {
        delay(update_interval);
        matrix[y][x] = 0;
        displayPixel(y, x);
        radians = (angle - 90) * PI / 180;
        ball_x += constrain(cos(radians) * 1.5, -1, 1);
        x = constrain(round(ball_x), 0, 31);
        //matrix[15][x] = 1;
        displayPixel(15, x);
        Serial.println(F("GAME OVER"));
        delay(500);
        ball_x = 14;
        ball_y = 11;
        x = 14;
        y = 11;
        angle = 45;
        update_interval = 150;
        update_count = 0;
        score = 0;
        Pong_displayScore(score);
      }

      if (x <= 0 || x >= 31) {
        angle = -angle % 360;
      }
      if (y <= 1 || y >= 14) {
        angle = (180 - angle) % 360; 
      }
      if (y == 14) {
        angle = Pong_paddleBounce(x, angle);
        score++;
        Pong_displayScore(score);
      }
      if (y == 14 || y == 1) {
        update_count = (update_count + 1) % ((180 - update_interval) / 23);
        if (update_count == 0 && update_interval > 30) {
          update_interval -= 4;
        }
        lcd.setCursor(12, 1);
        lcd.print((String) update_interval + "  ");
      }
    }
  }
}

void Pong_displayScore(int score) {
  lcd.setCursor(0, 1);
  lcd.print(F("Score: "));
  lcd.print(score);
  lcd.print(F("   "));
}

int Pong_paddleBounce(int x, int angle) {
  int y = 15;
  if (angle > 180) angle -= 360;

  const int angles[] = {25, 45, 67}; 

  int angle_step;
  if      (angle == -angles[2])
    angle_step = 1;
  else if (angle == -angles[1])
    angle_step = 2;
  else if (angle == -angles[0])
    angle_step = 3;
  else if (angle == angles[0])
    angle_step = 4;
  else if (angle == angles[1])
    angle_step = 5;
  else if (angle == angles[2])
    angle_step = 6;

  if (paddle_width == 7) {
    if ((matrix[y][x - 1] == 0 || matrix[y][x - 2] == 0) && angle_step > 1) {
      angle_step--;
    } else
    if ((matrix[y][x + 1] == 0 || matrix[y][x + 2] == 0) && angle_step < 6) {
      angle_step++;
    }
  }
  else {//paddle_width == 3 or 5
    if (matrix[y][x - 1] == 0 && angle_step > 1) {
      angle_step--;
    } else
    if (matrix[y][x + 1] == 0 && angle_step < 6) {
      angle_step++;
    }
  }

  if (matrix[y][x] == 0 && matrix[y][x - 1] == 0 && angle_step > 1) {
    angle_step--;
  } else
  if (matrix[y][x] == 0 && matrix[y][x + 1] == 0 && angle_step < 6) {
    angle_step++;
  }
  switch (angle_step) {
    case 1:
      angle = -angles[2];
      break;
    case 2:
      angle = -angles[1];
      break;
    case 3:
      angle = -angles[0];
      break;
    case 4:
      angle = angles[0];
      break;
    case 5:
      angle = angles[1];
      break;
    case 6:
      angle = angles[2];
      break;
  }
  return angle;
}

void Pong_paddleControl(int ball_speed) {
  bool draw_paddle;
  int paddle_cooldown = 20 + ball_speed / 7;
  if (joystick_moveLeft() && paddle_pos - paddle_width / 2 > 0 && currentMillis - previousMillis_Pong_paddle_cooldown > paddle_cooldown) {
    previousMillis_Pong_paddle_cooldown = currentMillis;
    paddle_pos--;
    draw_paddle = true;
    matrix[15][paddle_pos + paddle_width / 2 + 1] = 0;
  }
  if (joystick_moveRight() && paddle_pos + paddle_width / 2 < 31 && currentMillis - previousMillis_Pong_paddle_cooldown > paddle_cooldown) {
    previousMillis_Pong_paddle_cooldown = currentMillis;
    paddle_pos++;
    draw_paddle = true;
    matrix[15][paddle_pos - paddle_width / 2 - 1] = 0;
  }
  if (draw_paddle) {
    draw_paddle = false;
    for (int x = paddle_pos - paddle_width / 2; x <= paddle_pos + paddle_width / 2; x++) {
      matrix[15][x] = 1;
      displayRow(15);
    }
  }
}

void Pong_selectMode() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(F("Difficulty"));
  bool refresh_ldc = true;
  while (!joystick_isPressed() && !false) { ////////////skip

    if (joystick_moveLeft() && paddle_width <= 5) {
      paddle_width += 2;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveRight() && paddle_width >= 5) {
      paddle_width -= 2;
      refresh_ldc = true;
      joystick_cooldown = true;
    }

    if (refresh_ldc) {
      refresh_ldc = false;
      lcd.setCursor(0, 1);
      if (paddle_width == 7) {
        lcd.print(F("EASY normal hard"));
      }
      if (paddle_width == 5) {
        lcd.print(F("easy NORMAL hard"));
      }  
      if (paddle_width == 3) {
        lcd.print(F("easy normal HARD"));
      }
      matrix[15][10 - paddle_width / 2] = 0;
      matrix[15][12 + paddle_width / 2] = 0;
      for (int x = 0; x < paddle_width; x++) {
        matrix[15][11 + x - paddle_width / 2] = 1;
      }
      displayMatrix();
    }
    if (joystick_cooldown) {
      joystick_cooldown = false;
      delay(300);
    }
    if (joystick_moveUp()) {
      go_home = true;
      return;
    }
  }
}

void Paint() {
  clearMatrix();
  displayMatrix();
  lcd.clear();
  lcd.setCursor(0, 1);
  lcd.print(F("hold for options"));
  while (!joystick_isReleased()) {
    currentMillis = millis();
  }
  previousMillis_joystick_currently_pressed = millis();            // in case button is pressed in first iteration of while loop
  previousMillis_joystick_currently_pressed_stationary = millis(); // these vars are not set yet until after function that sets them is called.
  in_program = true;
  
  while(in_program) {
    currentMillis = millis();
    
    Paint_titleAnimation();
    // note: draw should be called before move so that the first pixel doesn't get skipped when drawing while moving over the screen
    Paint_draw();
    Paint_CursorMove();
    Paint_cursorAnimation();

    if (joystick_isPressedDuration(true) > 800) {
      clearMatrixOverwrite();
      displayMatrix();
      Paint_options();

      lcd.clear();
      lcd.setCursor(0, 1);
      lcd.print(F("hold for options"));
      joystick_pressed_duration_stationary = 0;
      while (!joystick_isReleased()) {
        currentMillis = millis();
      }
    }
  }
  clearMatrix();
}

void Paint_options() {
  bool refresh_ldc = true;
  int8_t x = 0;
  int8_t y = 0;
  bool page = 0;
  int8_t option;
  enum options {
    mode,
    size,
    speed,
    save,
    load,
    more,
    back,
    exit
  };
  while (true) {

    if (joystick_moveLeft()) {
      if (x > 0 && page == 0 || x > 1 && page == 1) x--;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveRight()) {
      if (x < 2) x++;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveUp()) {
      if (y == 1) y = 0;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveDown()) {
      if (y == 0) y = 1;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_isPressed()) {
      joystick_cooldown = true;
      switch (option) {
        case back:
          return;
        case exit:
          in_program = false;
          return;
        case more:
          page = !page;
          break;
        case mode:
          Paint_options_mode();
          break;
        case size:
          Paint_options_size();
          break;
        case speed:
          Paint_options_speed();
          break;
        case save:
          Paint_options_saveLoad(false);
          break;
        case load:
          Paint_options_saveLoad(true);
          break;
      }
      refresh_ldc = true;
      if (x != 2 || y != 1) { // if x, y was not on the "More" option, aka returned from another option, set cursor to "Back"
        x = 2;
        y = 0;
      }
    }

    if (refresh_ldc) {
      refresh_ldc = false;
      lcd.setCursor(0,0);
      if (page == 0) {
        lcd.print(F(" Mode Size Back "));
        lcd.setCursor(0,1);
        lcd.print(F(" Save Load More "));
        if (x == 0 && y == 0) {
          lcd.setCursor(0,0);
          lcd.print(F(">Mode<Size Back "));
          option = options::mode;
        }
        if (x == 1 && y == 0) {
          lcd.setCursor(0,0);
          lcd.print(F(" Mode>Size<Back "));
          option = options::size;
        }
        if (x == 2 && y == 0) {
          lcd.setCursor(0,0);
          lcd.print(F(" Mode Size>Back<"));
          option = options::back;
        }
        if (x == 0 && y == 1) {
          lcd.setCursor(0,1);
          lcd.print(F(">Save<Load More "));
          option = options::save;
        }
        if (x == 1 && y == 1) {
          lcd.setCursor(0,1);
          lcd.print(F(" Save>Load<More "));
          option = options::load;
        }
        if (x == 2 && y == 1) {
          lcd.setCursor(0,1);
          lcd.print(F(" Save Load>More<"));
          option = options::more;
        }
      }
      else {
        lcd.print(F("      Exit Back "));
        lcd.setCursor(0,1);
        lcd.print(F("     Speed More "));
        if (x == 1 && y == 0) {
          lcd.setCursor(0,0);
          lcd.print(F("     >Exit<Back "));
          option = options::exit;
        }
        if (x == 2 && y == 0) {
          lcd.setCursor(0,0);
          lcd.print(F("      Exit>Back<"));
          option = options::back;
        }
        if (x == 1 && y == 1) {
          lcd.setCursor(0,1);
          lcd.print(F("    >Speed<More "));
          option = options::speed;
        }
        if (x == 2 && y == 1) {
          lcd.setCursor(0,1);
          lcd.print(F("     Speed>More<"));
          option = options::more;
        }
      }
    }
    if (joystick_cooldown) {
      joystick_cooldown = false;
      delay(220);
    }
  }
}
void Paint_options_mode() {
  lcd.clear();
  bool refresh_ldc = true;
  int8_t x = Paint_mode != 1;  // if paint mode is not 1 (invert), it must be (draw) or (erease) which are at x = 1
  int8_t y = Paint_mode != 3;  // if paint mode is not 3 (draw), it must be (invert) or (erease) which are at y = 1
  while (true) {
    if (joystick_moveLeft()) {
      if (x == 1 && y == 1) x = 0;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveRight()) {
      if (x == 0 && y == 1) x = 1;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveUp()) {
      if (y == 1 && x == 1) y = 0;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveDown()) {
      if (y == 0) y = 1;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_isPressed()) {
      return;
    }

    if (refresh_ldc) {
      refresh_ldc = false;
      lcd.setCursor(0, 0);
      if (x == 0) {
        lcd.print(F("MODE:    Draw  "));
        lcd.setCursor(0, 1);
        lcd.print(F(">Invert< Erase "));
        Paint_mode = 1;
      }
      if (x == 1 && y == 1) {
        lcd.print(F("MODE:    Draw  "));
        lcd.setCursor(0, 1);
        lcd.print(F(" Invert >Erase<"));
        Paint_mode = 2;
      }
      if (y == 0) {
        lcd.print(F("MODE:   >Draw< "));
        lcd.setCursor(0, 1);
        lcd.print(F(" Invert  Erase "));
        Paint_mode = 3;
      }
    }
    if (joystick_cooldown) {
      joystick_cooldown = false;
      delay(220);
    }
  }
}
void Paint_options_size() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(F("SIZE:"));
  bool refresh_ldc = true;
  int8_t x = Paint_brush_size - 1;
  while (true) {
    if (joystick_moveLeft()) {
      if (x > 0) x--;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveRight()) {
      if (x < 2) x++;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_isPressed()) {
      return;
    }

    if (refresh_ldc) {
      refresh_ldc = false;
      lcd.setCursor(0, 1);
      if (x == 0) {
        lcd.print(F(">1x1< 2x2  3x3 "));
        Paint_brush_size = 1;
      }
      if (x == 1) {
        lcd.print(F(" 1x1 >2x2< 3x3 "));
        Paint_brush_size = 2;
      }
      if (x == 2) {
        lcd.print(F(" 1x1  2x2 >3x3<"));
        Paint_brush_size = 3;
      }
    }
    if (joystick_cooldown) {
      joystick_cooldown = false;
      delay(220);
    }
  }
}
void Paint_options_speed() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(F("SPEED:"));
  bool refresh_ldc = true;
  while (true) {
    if (joystick_moveUp()) {
      if (Paint_speed < 1000) Paint_speed += 25;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_moveDown()) {
      if (Paint_speed > 75) Paint_speed -= 25;
      refresh_ldc = true;
      joystick_cooldown = true;
    }
    if (joystick_isPressed()) {
      return;
    }

    if (refresh_ldc) {
      refresh_ldc = false;
      lcd.setCursor(0, 1);
      lcd.write(0);
      lcd.print((String) Paint_speed + "ms  ");
    }
    if (joystick_cooldown) {
      joystick_cooldown = false;
      delay(180);
    }
  }
}
void Paint_options_saveLoad(bool load) {
  bool refresh_ldc = true;
  int8_t x = 1;
  int8_t index = 1;
  
  while (true) {
    if (joystick_moveUp()) {
      if (index > 0 && x == 1) {
        index--;
        refresh_ldc = true;
        joystick_cooldown = true;
      }
    }
    if (joystick_moveDown()) {
      if (index < 4 && x == 1) {
        index++;
        refresh_ldc = true;
        joystick_cooldown = true;
      }
    }
    if (joystick_moveLeft()) {
      if (x == 1) {
        x = 0;
        refresh_ldc = true;
        joystick_cooldown = true;
      }
    }
    if (joystick_moveRight()) {
      if (x == 0) {
        x = 1;
        refresh_ldc = true;
        joystick_cooldown = true;
      }
    }
    if (joystick_isPressed()) {
      if (x == 0) {
        displayMatrix();
        return;
      }
      else {
        if (load) {
          for (int y = 0; y < 16; y++) {
            for (int x = 0; x < 32; x += 8) {
              uint8_t packedByte = Paint_saves_byte_matrix[index][y][x / 8];
              for (int bit = 0; bit < 8; bit++) {
                matrix[y][x + bit] = (packedByte >> bit) & 1;
              }
            }
          }
          displayMatrix();
          lcd.clear();
          lcd.setCursor(0, 0);
          lcd.print(F("Loaded "));
        }
        else {
          Paint_options_saveName(index);
          lcd.clear();
          lcd.setCursor(0, 0);
          lcd.print(F("Saved "));
        }
        lcd.print(Paint_saves_name[index]);
        lcd.print(F("!"));
        delay(1000);
        return;
      }
    }

    if (refresh_ldc) {
      refresh_ldc = false;
      lcd.clear();
      lcd.setCursor(0, 0);
      if (load) {
        lcd.print(F("LOAD:  "));
      }
      else {
        lcd.print(F("SAVE:  "));
      }
      if (index > 0) {
        lcd.print((String) (index) + " " + Paint_saves_name[index - 1]);
      }
      lcd.setCursor(0, 1);
      if (x == 0) {
        lcd.print(F(">Back< "));
        displayMatrix();
      }
      else {
        lcd.print(F(" Back ~"));
      }
      lcd.print((String) (index + 1) + " " + Paint_saves_name[index]);

      if (load) {
        for (int y = 0; y < 16; y++) {
          for (int x = 0; x < 32; x += 8) {
            uint8_t packedByte = Paint_saves_byte_matrix[index][y][x / 8];
            for (int bit = 0; bit < 8; bit++) {
              matrix_overwrite[y][x + bit] = (packedByte >> bit) & 1;
              // compares bit from packedByte (shifts byte to the left) with 1
              // if the byte is 0b00101110 and bit is 2, 0b00101110 >> 2 = 0b00001011. 0b00001011 & 0b00000001 results in 1
            }
          }
        }
        displayMatrix();
      }
    }
    if (joystick_cooldown) {
      joystick_cooldown = false;
      delay(220);
    }
  }
}
void Paint_options_saveName(int8_t index) {
  lcd.clear();
  bool refresh_ldc = true;
  int8_t x = 1;
  while (true) {
    if (joystick_moveLeft()) {
      if (x == 1) {
        x = 0;
        refresh_ldc = true;
      }
    }
    if (joystick_moveRight()) {
      if (x == 0) {
        x = 1;
        refresh_ldc = true;
      }
    }
    if (joystick_isPressed()) {
      if (x == 1) {
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print(F("SET NAME:"));
        lcd.setCursor(0, 1);
        lcd.write(0);
        x = 0;
        refresh_ldc = true;
        const char chars[37+1] = {"_abcdefghijklmnopqrstuvwxyz0123456789"};
        int8_t letter_index[7] = {0};
        while (true) {

          if (joystick_moveUp() && x < 7) {
            if (letter_index[x] < 36) {
              letter_index[x]++;
            } else {
              letter_index[x] = 0;
            }
            refresh_ldc = true;
            joystick_cooldown_2 = true;
          }
          if (joystick_moveDown() && x < 7) {
            if (letter_index[x] > 0) {
              letter_index[x]--;
            } else {
              letter_index[x] = 36;
            }
            refresh_ldc = true;
            joystick_cooldown_2 = true;
          }
          if (joystick_moveLeft() && !joystick_moveUp() && !joystick_moveDown()) {
            if (x > 0) {
              x--;
              refresh_ldc = true;
              joystick_cooldown = true;
            }
          }
          if (joystick_moveRight() && !joystick_moveUp() && !joystick_moveDown()) {
            if (x < 7) {
              x++;
              refresh_ldc = true;
              joystick_cooldown = true;
            }
          }

          if (refresh_ldc) {
            refresh_ldc = false;
            lcd.setCursor(10, 0);
            if (x == 7) {
              lcd.print(F(">Save<"));
            } 
            else {
              lcd.print(F(" Save "));
            }
            for (int i = 0; i < 7; i++) {
              lcd.setCursor(2 * i + 1, 1);
              lcd.print((String) " " + chars[letter_index[i]] + " ");
            }
            if (x != 7) {
              lcd.setCursor(2 * x + 1, 1);
              lcd.print(">");
              lcd.setCursor(2 * x + 3, 1);
              lcd.print("<");
            }
          }
          if (joystick_cooldown) {
            joystick_cooldown = false;
            delay(220);
          }
          if (joystick_cooldown_2) {
            joystick_cooldown_2 = false;
            delay(160);
          }

          if (joystick_isPressed() && x == 7) { 
            // save name
            for (int i = 0; i < 7; i++) {
              Paint_saves_name[index][i] = chars[letter_index[i]];
            }
            break;
          }
        }
      }
      // save matrix
      for (int y = 0; y < 16; y++) {
        for (int x = 0; x < 32; x += 8) {
          uint8_t packedByte = 0;
          for (int bit = 0; bit < 8; bit++) {
            packedByte += matrix[y][x + bit] << bit;
          }
          Paint_saves_byte_matrix[index][y][x / 8] = packedByte;
        }
      }
      return;
    }

    if (refresh_ldc) {
      refresh_ldc = false;
      lcd.setCursor(0, 0);
      lcd.print((String) "NAME: " + Paint_saves_name[index]);
      lcd.setCursor(0, 1);
      if (x == 0) {
        lcd.print(F(">Keep<   Change "));
      }
      else {
        lcd.print(F(" Keep   >Change<"));
      }
    }
  }
}

void Paint_setPixels(bool overwrite, bool overwrite_state = false) {
  if (Paint_brush_size == 1) {
    if (overwrite) {
      matrix_overwrite[posY][posX] = overwrite_state;
    } 
    else {
      if (Paint_mode == 1) matrix[posY][posX] = !matrix[posY][posX];
      else if (Paint_mode == 2) matrix[posY][posX] = 0;
      else matrix[posY][posX] = 1;
    }
  }

  else if (Paint_brush_size == 2) {
    for (int x = 0; x <= 1; x++) {
      for (int y = 0; y <= 1; y++) {
        if (posX + x < 32 && posY + y < 16) {  // checks if point not out of array's bounds
          if (overwrite) {
            matrix_overwrite[posY+y][posX+x] = overwrite_state;
          }
          else {
            if (Paint_mode == 1) matrix[posY+y][posX+x] = !matrix[posY+y][posX+x];
            else if (Paint_mode == 2) matrix[posY+y][posX+x] = 0;
            else matrix[posY+y][posX+x] = 1;
          }
        }
      }
    }
  }

  else {
    for (int x = -1; x <= 1; x++) {
      for (int y = -1; y <= 1; y++) {
        if (posX + x >=0 && posY + y >= 0 && posX + x < 32 && posY + y < 16) {
          if (overwrite) {
            matrix_overwrite[posY+y][posX+x] = overwrite_state;
          }
          else {
            if (Paint_mode == 1) matrix[posY+y][posX+x] = !matrix[posY+y][posX+x];
            else if (Paint_mode == 2) matrix[posY+y][posX+x] = 0;
            else matrix[posY+y][posX+x] = 1;
          }
        }
      }
    }
  }
}

void Paint_draw() {
  if (joystick_isReleased() || joystick_isPressedDuration(false) > 0 && (joystick_moveLeft() || joystick_moveRight() || joystick_moveUp() || joystick_moveDown())) {
    
    if (Paint_mode == 1) {
      if (!Paint_invert_cooldown) {
        Paint_invert_cooldown = true;
        Paint_setPixels(false);
      }
    }
    else {
      Paint_setPixels(false);
    }
  } 
  else {
    Paint_invert_cooldown = false;
  }
}

void Paint_CursorMove() {
  if (joystick_moveLeft() && posX > 0) {
    Paint_cursorMoveAnimation();
    if (currentMillis - previousMillis_joystick_input_X > Paint_speed) {
      previousMillis_joystick_input_X = currentMillis;
      Paint_invert_cooldown = false;
      posX--;
    }
  }
  if (joystick_moveRight() && posX < 31) {
    Paint_cursorMoveAnimation();
    if (currentMillis - previousMillis_joystick_input_X > Paint_speed) {
      previousMillis_joystick_input_X = currentMillis;
      Paint_invert_cooldown = false;
      posX++;
    }
  }
  if (joystick_moveUp() && posY > 0) {
    Paint_cursorMoveAnimation();
    if (currentMillis - previousMillis_joystick_input_Y > Paint_speed) {
      previousMillis_joystick_input_Y = currentMillis;
      Paint_invert_cooldown = false;
      posY--;
    }
  }
  if (joystick_moveDown() && posY < 15) {
    Paint_cursorMoveAnimation();
    if (currentMillis - previousMillis_joystick_input_Y > Paint_speed) {
      previousMillis_joystick_input_Y = currentMillis;
      Paint_invert_cooldown = false;
      posY++;
    }
  }
}

void Paint_cursorMoveAnimation() {
  if (currentMillis - previousMillis_joystick_move_animation > Paint_speed / 2) {
    previousMillis_joystick_move_animation = currentMillis;
    previousMillis_cursor_animation = 0;
  }
}

void Paint_cursorAnimation() {
  if (currentMillis - previousMillis_cursor_animation > Paint_cursor_flicker_cooldown) {
    previousMillis_cursor_animation = currentMillis;
    Paint_cursor = !Paint_cursor;
    if (Paint_cursor) {
      Paint_setPixels(true, 1);
      if (matrix[posY][posX] == 1) {
        previousMillis_cursor_animation -= 200;
      }
    } 
    else {
      clearMatrixOverwrite();
      if (matrix[posY][posX] == 1) {
        previousMillis_cursor_animation -= 300;
      }
      Paint_setPixels(true, 0);
    }
    displayMatrix();
  }
}

void Paint_titleAnimation() {
  lcd.setCursor(3, 0);
  if (currentMillis - previousMillis_Paint_move_title > 300) {
    previousMillis_Paint_move_title = currentMillis;
    if (Paint_title_move_direction) {
      Paint_title_position++;
    }
    if (!Paint_title_move_direction) {
      Paint_title_position--;
    }
    if (Paint_title_position == 5 || Paint_title_position == 0 ) {
      Paint_title_move_direction = !Paint_title_move_direction;
    }
    String e;
    for (int i = 0; i < Paint_title_position; i++) {
      e+=" ";
    }
    lcd.print((String) e + "Paint ");
  }
}

void displayMatrix() {
  for (int addr = 0; addr < 4; addr++) {
    for (int row = 0; row < 16; row++) {
      int byteInfo = 0;
      for (int col = 0; col < 8; col++) {
        if (matrix_overwrite[row][col + addr * 8] == -1) { // -1 is the default value of matrix_overwrite. 0 and 1 will overwrite what's in matrix
          byteInfo += matrix[row][col + addr * 8] << col;
        } else {
          byteInfo += matrix_overwrite[row][col + addr * 8] << col;
        }
      }
      if (row < 8) {
        lc_1.setRow(addr, 7 - row, byteInfo);
      } else {
        lc_2.setRow(addr, 7 - row % 8, byteInfo);
      }
    }
  }
}
void displayRow(int row) {
  for (int addr = 0; addr < 4; addr++) {
    int byteInfo = 0;
    for (int col = 0; col < 8; col++) {
      if (matrix_overwrite[row][col + addr * 8] == -1) { // -1 is the default value of matrix_overwrite. 0 and 1 will overwrite what's in matrix
        byteInfo += matrix[row][col + addr * 8] << col;
      } else {
        byteInfo += matrix_overwrite[row][col + addr * 8] << col;
      }
    }
    if (row < 8) {
      lc_1.setRow(addr, 7 - row, byteInfo);
    } else {
      lc_2.setRow(addr, 7 - row % 8, byteInfo);
    }
  }
}
void displayPixel(int row, int col) {
  for (int addr = 0; addr < 4; addr++) {
    int state = 0;
    if (matrix_overwrite[row][col + addr * 8] == -1) { // -1 is the default value of matrix_overwrite. 0 and 1 will overwrite what's in matrix
      state = matrix[row][col];
    } else {
      state = matrix_overwrite[row][col];
    }
    setLed(row, col, state);
  }
}
void fillMatrix(const uint8_t* array, int size_row, int size_col, int pos_row, int pos_col) { // this will overwrite matrix if value is 0 or 1. -1 is masked
  for (int y = 0; y < size_row; y++) {
    for (int x = 0; x < size_col; x++) {
      // the passed array is a 1d array but is used as a 2d array so this calculates the correct index for the position x y of the 1d array.
      int index = y*size_col+x;
      int value = pgm_read_byte(array + index);
      if (value == 0 || value == 1) {
        matrix[y + pos_row][x + pos_col] = value;
      }
    }
  }
}
void fillMatrixOverwrite(const uint8_t* array, int size_row, int size_col, int pos_row, int pos_col) { // this will overwrite matrix if value is 0 or 1. -1 is masked
  for (int y = 0; y < size_row; y++) {
    for (int x = 0; x < size_col; x++) {
      // the passed array is a 1d array but is used as a 2d array so this calculates the correct index for the position x y of the 1d array.
      int index = y*size_col+x;
      int value = pgm_read_byte(array + index);
      matrix_overwrite[y + pos_row][x + pos_col] = value;
    }
  }
}
void clearMatrix() {
  for (int row = 0; row < 16; row++) {
    for (int col = 0; col < 32; col++) {
      matrix[row][col] = 0;
    }
  }
}
void clearMatrixOverwrite() {
  for (int row = 0; row < 16; row++) {
    for (int col = 0; col < 32; col++) {
      matrix_overwrite[row][col] = -1;
    }
  }
}
void setLed(int row, int col, bool state){
  if (row < 8) {
    lc_1.setLed(col / 8, 7 - row, 7 - col % 8, state);
  } else {
    lc_2.setLed(col / 8, 7 - (row % 8), 7 - col % 8, state);
  }
}

bool joystick_pressedState() {
  joystickButton.loop();
  return joystickButton.getState();
}
bool joystick_isPressed() {
  joystickButton.loop();
  return joystickButton.isPressed();
}
bool joystick_isReleased() {
  if (button_state != joystick_pressedState()) {
    button_state = joystick_pressedState();
    return joystick_pressedState();
  }
  return 0;
}
int  joystick_isPressedDuration(bool stationary) {  //stationary determines wether or not the joystick may move while pressed

  joystickButton.loop();
  if (stationary) {
    if (currentMillis - previousMillis_joystick_currently_pressed_stationary > 50 && !joystickButton.getState()) {
      if (joystick_moveLeft() || joystick_moveRight() || joystick_moveUp() || joystick_moveDown()) {
        joystick_pressed_duration_stationary = 0;
      }
      else {
        joystick_pressed_duration_stationary += currentMillis - previousMillis_joystick_currently_pressed_stationary;
      }
      previousMillis_joystick_currently_pressed_stationary = currentMillis;
    }
    else if (currentMillis - previousMillis_joystick_currently_pressed_stationary > 100) { //previous if-statmenet didn't trigger two times meaning the button was released
      joystick_pressed_duration_stationary = 0;
      previousMillis_joystick_currently_pressed_stationary = currentMillis;
    }
  }
  else {
    if (currentMillis - previousMillis_joystick_currently_pressed > 50 && !joystickButton.getState()) {
      joystick_pressed_duration_ += currentMillis - previousMillis_joystick_currently_pressed;
      previousMillis_joystick_currently_pressed = currentMillis;
    }
    else if (currentMillis - previousMillis_joystick_currently_pressed > 100) {
      joystick_pressed_duration_ = 0;
      previousMillis_joystick_currently_pressed = currentMillis;
    }
  }
  return stationary ? joystick_pressed_duration_stationary : joystick_pressed_duration_;
}
bool joystick_moveLeft() {
  return analogRead(A0) < 300;
}
bool joystick_moveRight() {
  return analogRead(A0) > 1024 - 300;
}
bool joystick_moveUp() {
  return analogRead(A1) < 300;
}
bool joystick_moveDown() {
  return analogRead(A1) > 1024 - 300;
}

void gameselector() {
  animation_paint = 0;posX = 0; posY = 0; //needed for smiley animation
  lcd.setCursor(0, 0);
  lcd.print(F("< SELECT GAME >"));
  lcd.setCursor(0, 1);
  lcd.print(gameSelectorList[gameselector_index]);
  while (!joystick_isPressed()) {
    unsigned long currentMillis = millis();

    if (joystick_moveLeft()) {
      if (currentMillis - previousMillis_joystick_input_X > cooldown_500) {
        previousMillis_joystick_input_X = currentMillis;
        previousMillis_gameSelector = 0;
        gameselector_index--;
        if (gameselector_index < 0) gameselector_index = 3;
        clearMatrix();
        lcd.setCursor(0, 1);
        lcd.print(gameSelectorList[gameselector_index]);
      }
    }
    else if (joystick_moveRight()) {
      if (currentMillis - previousMillis_joystick_input_X > cooldown_500) {
        previousMillis_joystick_input_X = currentMillis;
        previousMillis_gameSelector = 0;
        gameselector_index = (gameselector_index + 1) % 4;
        clearMatrix();
        lcd.setCursor(0, 1);
        lcd.print(gameSelectorList[gameselector_index]);
      }
    }
    
    if (gameselector_index == 0) {

      if (currentMillis - previousMillis_gameSelector > 500) {
        previousMillis_gameSelector = currentMillis;
        animation_TTT = animation_TTT % 4 + 1;
        if (animation_TTT == 1) {
          fillMatrix(shape_O_large,12,12,2,2);
        } else if (animation_TTT == 3) {
          fillMatrix(shape_X_large,12,12,2,2);
        } else {
          fillMatrix(shape_grid,12,12,2,2);
        }
        displayMatrix();
      }
    } else if (gameselector_index == 1) {
      fillMatrix(shape_pong,16,32,0,0);
      displayMatrix();
    } else if (gameselector_index == 2) {

      if (currentMillis - previousMillis_gameSelector > 100) {
        previousMillis_gameSelector = currentMillis;
        fillMatrix(shape_smiley,8,8,posY,posX);
        animation_paint++;
        if (animation_paint <= 8) posX++;
        if (animation_paint > 8 && animation_paint <= 16) posY++;
        if (animation_paint > 16 && animation_paint <= 24) posX--;
        if (animation_paint > 24 && animation_paint <= 32) posY--;
        if (animation_paint == 32) animation_paint = 0;
        displayMatrix();
      }
    } else if (gameselector_index == 3) {

      if (currentMillis - previousMillis_gameSelector > 500) {
        previousMillis_gameSelector = currentMillis;
        animation_settings = animation_settings % 2 + 1;
        if (animation_settings == 1) {
          fillMatrix(shape_settings_1,14,14,1,1);
        } else {
          fillMatrix(shape_settings_2,14,14,1,1);
        }
        displayMatrix();
      }
    }
  }

  // when pressed
  if (gameselector_index == 0) {
    TTT_selectMode();
    TicTacToe();
  }
  if (gameselector_index == 1) {
    Pong();
  }
  if (gameselector_index == 2) {
    posX = 0; posY = 0;
    Paint();
  }
  if (gameselector_index == 3) {
    settings();
  }
}

void settings() {
  lcd.clear();
  fillMatrix(shape_settings_1,14,14,1,1);
  displayMatrix();
  while (!joystick_isPressed()) {

    if (joystick_moveLeft() && !joystick_moveUp() && !joystick_moveDown()) {
      settings_index--;
      if (settings_index < 0) settings_index = 1;
      joystick_cooldown = true;
    } else if (joystick_moveRight() && !joystick_moveUp() && !joystick_moveDown()) {
      settings_index = (settings_index + 1) % 2;
      joystick_cooldown = true;
    }
    lcd.setCursor(0, 0);
    lcd.print(settingsList[settings_index]);
    
    if (settings_index == 0) {

      if (joystick_moveUp() && setting_brightness < 15) {
        setting_brightness++;
        joystick_cooldown_2 = true;
      } else
      if (joystick_moveDown() && setting_brightness > 0) {
        setting_brightness--;
        joystick_cooldown_2 = true;
      }
      lcd.setCursor(0,1);
      lcd.write(0);
      lcd.print(setting_brightness);
      lcd.print("   ");
      lc_1.setIntensity(0, setting_brightness);lc_1.setIntensity(1, setting_brightness);
      lc_1.setIntensity(2, setting_brightness);lc_1.setIntensity(3, setting_brightness);
      lc_2.setIntensity(0, setting_brightness);lc_2.setIntensity(1, setting_brightness);
      lc_2.setIntensity(2, setting_brightness);lc_2.setIntensity(3, setting_brightness);
    } 
    else if (settings_index == 1) {

      if (joystick_moveUp() && setting_volume < 100) {
        setting_volume += 10;
        joystick_cooldown_2 = true;
      } else
      if (joystick_moveDown() && setting_volume > 0) {
        setting_volume -= 10;
        joystick_cooldown_2 = true;
      }
      lcd.setCursor(0,1);
      lcd.write(0);
      lcd.print((String) setting_volume + "%");
      lcd.print("  ");
    }
    
    if (joystick_cooldown) {
      joystick_cooldown = false;
      delay(400);
    }
    if (joystick_cooldown_2) {
      joystick_cooldown_2 = false;
      delay(200);
    }
  }
}

void print(String a) {
  Serial.println(a);
}
